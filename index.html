<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RUSSIAN ROULETTE 2D</title>
    <style>
        body { margin: 0; background: #1a472a; color: #f0c040; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; overflow: hidden; }
        #menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        .menu-box { background: #222; border: 4px solid #f0c040; padding: 40px; border-radius: 10px; text-align: center; }
        h1 { font-size: 48px; margin-bottom: 20px; color: #f0c040; }
        .input-group { margin-bottom: 20px; }
        label { font-size: 20px; display: block; margin-bottom: 10px; }
        input { font-size: 20px; padding: 5px; width: 60px; text-align: center; background: #333; color: #fff; border: 2px solid #f0c040; }
        button { font-size: 24px; padding: 10px 30px; background: #f0c040; color: #222; border: none; cursor: pointer; font-weight: bold; border-radius: 5px; }
        button:hover { background: #fff; }
        #canvas { display: block; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .log { position: absolute; bottom: 20px; left: 20px; font-family: monospace; font-size: 18px; max-height: 200px; overflow-y: hidden; }
        .log-entry { margin: 5px 0; text-shadow: 1px 1px #000; }
    </style>
</head>
<body>
    <div id="menu-overlay">
        <div class="menu-box">
            <h1>RUSSIAN ROULETTE</h1>
            <div class="input-group">
                <label for="ai-count">How many AI opponents? (1-5)</label>
                <input type="number" id="ai-count" min="1" max="5" value="1">
            </div>
            <button id="start-btn">START GAME</button>
            <div id="controls" style="display:none; margin-top:20px;">
                <button id="trigger-btn">PULL TRIGGER</button>
                <button id="spin-btn" style="margin-left:10px; background:#888;">SPIN</button>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>
    <div id="ui-layer">
        <div id="log" class="log"></div>
    </div>

    <script>
        class Renderer {
            constructor(canvas, game) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.game = game;
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            draw() {
                const ctx = this.ctx;
                const width = this.canvas.width;
                const height = this.canvas.height;

                // Background
                ctx.fillStyle = '#1a472a';
                ctx.fillRect(0, 0, width, height);

                // Table
                ctx.beginPath();
                ctx.ellipse(width / 2, height / 2, width * 0.4, height * 0.35, 0, 0, Math.PI * 2);
                ctx.fillStyle = '#0a5c2e';
                ctx.fill();
                ctx.strokeStyle = '#f0c040';
                ctx.lineWidth = 10;
                ctx.stroke();

                // Players
                const players = this.game.players;
                const radius = Math.min(width, height) * 0.3;
                players.forEach((p, i) => {
                    const angle = (i / players.length) * Math.PI * 2 - Math.PI / 2;
                    const x = width / 2 + Math.cos(angle) * radius;
                    const y = height / 2 + Math.sin(angle) * radius;

                    // Draw player circle
                    ctx.beginPath();
                    ctx.arc(x, y, 40, 0, Math.PI * 2);
                    ctx.fillStyle = p.alive ? (this.game.currentPlayerIdx === i ? '#f0c040' : '#444') : '#800';
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Name
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(p.name, x, y + 5);
                });

                // Revolver representation in center
                ctx.save();
                ctx.translate(width / 2, height / 2);
                // Rotate based on current chamber?
                ctx.rotate((this.game.revolver.currentChamber / 6) * Math.PI * 2);

                // Draw cylinder
                ctx.beginPath();
                ctx.arc(0, 0, 60, 0, Math.PI * 2);
                ctx.fillStyle = '#333';
                ctx.fill();
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 4;
                ctx.stroke();

                // Draw chambers
                for (let i = 0; i < 6; i++) {
                    const a = (i / 6) * Math.PI * 2;
                    ctx.beginPath();
                    ctx.arc(Math.cos(a) * 35, Math.sin(a) * 35, 12, 0, Math.PI * 2);
                    ctx.fillStyle = '#111';
                    ctx.fill();
                    if (i === 0) { // Indicator for "current" slot (top before rotation)
                        ctx.strokeStyle = '#f0c040';
                        ctx.stroke();
                    }
                }
                ctx.restore();

                requestAnimationFrame(() => this.draw());
            }
        }

        class Revolver {
            constructor() {
                this.chambers = new Array(6).fill(false); // false = blank, true = live
                this.currentChamber = 0;
            }

            loadRandom() {
                this.chambers.fill(false);
                // Randomly decide how many live rounds (1 to 3)
                const liveCount = Math.floor(Math.random() * 3) + 1;
                let loaded = 0;
                while (loaded < liveCount) {
                    const idx = Math.floor(Math.random() * 6);
                    if (!this.chambers[idx]) {
                        this.chambers[idx] = true;
                        loaded++;
                    }
                }
                this.currentChamber = Math.floor(Math.random() * 6);
                return liveCount;
            }

            spin() {
                this.currentChamber = Math.floor(Math.random() * 6);
            }

            pullTrigger() {
                const isLive = this.chambers[this.currentChamber];
                // In Russian Roulette, after firing, the next chamber is used.
                // If it was a blank, we move to the next.
                // If it was live, the game/round usually resets.
                const shotIdx = this.currentChamber;
                this.currentChamber = (this.currentChamber + 1) % 6;
                return isLive;
            }

            getPublicInfo() {
                // Returns how many total chambers are left in the sequence since last load
                // (Though in this game we just track shots fired)
                return {
                    current: this.currentChamber
                };
            }
        }

        class Game {
            constructor() {
                this.players = [];
                this.revolver = new Revolver();
                this.currentPlayerIdx = 0;
                this.isGameOver = false;
                this.shotsFiredInRound = 0;
                this.onLog = (msg) => {};
                this.onStateChange = () => {};
            }

            init(aiCount) {
                this.players = [{ name: 'PLAYER', isAI: false, alive: true }];
                for (let i = 0; i < aiCount; i++) {
                    this.players.push({ name: `AI ${i + 1}`, isAI: true, alive: true });
                }
                this.currentPlayerIdx = 0;
                this.isGameOver = false;
                this.startRound();
            }

            startRound() {
                const liveCount = this.revolver.loadRandom();
                this.shotsFiredInRound = 0;
                this.log(`Round started. ${liveCount} live rounds loaded. Cylinder spun.`);
                this.onStateChange();
            }

            log(msg) {
                this.onLog(msg);
            }

            nextTurn() {
                if (this.isGameOver) return;

                do {
                    this.currentPlayerIdx = (this.currentPlayerIdx + 1) % this.players.length;
                } while (!this.players[this.currentPlayerIdx].alive);

                this.onStateChange();

                if (this.players[this.currentPlayerIdx].isAI) {
                    setTimeout(() => this.aiTurn(), 1500);
                }
            }

            pullTrigger() {
                const player = this.players[this.currentPlayerIdx];
                this.log(`${player.name} pulls the trigger...`);

                const isLive = this.revolver.pullTrigger();
                this.shotsFiredInRound++;

                if (isLive) {
                    this.log(`BOOM! ${player.name} is eliminated.`);
                    player.alive = false;

                    const alivePlayers = this.players.filter(p => p.alive);
                    if (alivePlayers.length === 1) {
                        this.log(`GAME OVER! ${alivePlayers[0].name} WINS!`);
                        this.isGameOver = true;
                    } else {
                        setTimeout(() => this.startRound(), 2000);
                    }
                } else {
                    this.log(`*click*. ${player.name} survives.`);
                    setTimeout(() => this.nextTurn(), 1000);
                }
                this.onStateChange();
            }

            spin() {
                const player = this.players[this.currentPlayerIdx];
                this.log(`${player.name} spins the cylinder.`);
                this.revolver.spin();
                this.onStateChange();
                // After spinning, the player MUST still pull the trigger or it's just stalling.
                // In some variants spinning is a choice. Here we'll allow it once per turn?
                // For simplicity, let's say AI might spin.
            }

            aiTurn() {
                const decision = this.aiController.makeDecision(this.shotsFiredInRound);
                if (decision === 'spin') {
                    this.spin();
                    // After spinning, AI must fire (rules of this game variant)
                    setTimeout(() => this.pullTrigger(), 1000);
                } else {
                    this.pullTrigger();
                }
            }
        }

        class RussianRouletteAI {
            constructor() {
                // AI doesn't know the revolver's internal state
            }

            makeDecision(shotsFired) {
                // Heuristic: If shots fired is high, probability of live is higher.
                if (shotsFired >= 3 && Math.random() < 0.3) {
                    return 'spin';
                }
                return 'fire';
            }
        }

        // --- Initialization ---
        window.addEventListener('load', () => {
            const game = new Game();
            const renderer = new Renderer(document.getElementById('canvas'), game);
            const menu = document.getElementById('menu-overlay');
            const startBtn = document.getElementById('start-btn');
            const aiCountInput = document.getElementById('ai-count');
            const controls = document.getElementById('controls');
            const triggerBtn = document.getElementById('trigger-btn');
            const spinBtn = document.getElementById('spin-btn');
            const logElement = document.getElementById('log');

            game.onLog = (msg) => {
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.innerText = msg;
                logElement.appendChild(entry);
                logElement.scrollTop = logElement.scrollHeight;
                if (logElement.children.length > 8) {
                    logElement.removeChild(logElement.firstChild);
                }
            };

            game.onStateChange = () => {
                const currentPlayer = game.players[game.currentPlayerIdx];
                if (!game.isGameOver && currentPlayer && !currentPlayer.isAI) {
                    controls.style.display = 'block';
                } else {
                    controls.style.display = 'none';
                }
            };

            startBtn.addEventListener('click', () => {
                const aiCount = parseInt(aiCountInput.value) || 1;
                game.init(aiCount);
                menu.style.background = 'transparent';
                menu.style.pointerEvents = 'none';
                document.querySelector('.menu-box h1').style.display = 'none';
                document.querySelector('.input-group').style.display = 'none';
                startBtn.style.display = 'none';
                renderer.draw();
            });

            triggerBtn.addEventListener('click', () => {
                game.pullTrigger();
            });

            spinBtn.addEventListener('click', () => {
                game.spin();
            });
        });
    </script>
</body>
</html>
